#!/bin/bash

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Reset OPTIND for source compatibility
OPTIND=1

# Silence Job Control and Tracing
if [ -n "$ZSH_VERSION" ]; then
    setopt no_monitor no_xtrace 2>/dev/null
else
    set +x
fi

smart_exit() {
    # Check if we're in ZSH and if the script is being sourced
    if [[ -n "$ZSH_VERSION" ]]; then
        if [[ "$ZSH_EVAL_CONTEXT" == "toplevel" ]]; then
            exit "$1"
        else
            return "$1"
        fi
    else
        # Fallback for Bash
        if [[ "$0" == "$BASH_SOURCE" ]]; then
            exit "$1"
        else
            return "$1"
        fi
    fi
}

# Spinner function for background processes
show_spinner() {
    local pid=$1
    local message="$2"
    local delay=0.1
    local frames=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
    local i=0
    
    # Hide cursor
    printf "\033[?25l"
    
    while kill -0 "$pid" 2>/dev/null; do
        # Clear line and print message + frame
        printf "\r\c"
        printf "\033[K${GREEN}%s [%s]${NC}" "$message" "${frames[i]}"
        i=$(( (i % ${#frames[@]} ) + 1 ))
        sleep $delay
    done
    
    # Clear line and print final status
    printf "\r\033[K${GREEN}%s Done.${NC}\n" "$message"
    
    # Restore cursor
    printf "\033[?25h"
}

if [[ "$0" == "$BASH_SOURCE" ]]; then
    echo -e "${RED}Warning: This script is not being sourced. Directory changes (cd) will not persist.${NC}"
    echo -e "${RED}Please ensure you have run 'source ~/.zshrc' and are using the 'teardown' alias.${NC}"
fi

if [ ! -d ".git" ] && [ ! -f ".git" ]; then
    echo -e "${RED}This script must be run inside a git repository.${NC}"
    smart_exit 1; return 1
fi

FOLDER=$(pwd)
WORKTREE_NAME=$(basename "$FOLDER")

if [[ "$WORKTREE_NAME" == "master" ]] || [[ "$WORKTREE_NAME" == "develop" ]]; then
    echo -e "${RED}Critical: Cannot teardown '$WORKTREE_NAME' worktree. Aborting.${NC}"
    smart_exit 1; return 1
else
    echo -en "${GREEN}Are you sure you want to teardown worktree [$WORKTREE_NAME]? (y/n): ${NC}"
    read -r confirm
    if [[ ! "$confirm" =~ ^[yY]$ ]]; then
        echo -e "${RED}Teardown aborted.${NC}"
        smart_exit 0; return 0
    fi
fi
VALET_SITES_DIR="$HOME/.config/valet/Sites"
SITES_TO_RESTORE=()

# Find the best fallback worktree (develop > master > main)
FALLBACK_PATH=$(git worktree list | grep "/develop" | head -n 1 | awk '{print $1}')
if [ -z "$FALLBACK_PATH" ]; then
    FALLBACK_PATH=$(git worktree list | grep "/master" | head -n 1 | awk '{print $1}')
fi
if [ -z "$FALLBACK_PATH" ]; then
    FALLBACK_PATH=$(git worktree list | grep "/main" | head -n 1 | awk '{print $1}')
fi

# Check for uncommitted changes
if [ -n "$(git status --porcelain)" ]; then
    echo -e "${RED}Uncommitted changes detected in this worktree:${NC}"
    git status -s
    echo -en "${GREEN}Would you like to [m]ove them to fallback, [t]rash them, or [a]bort? (m/t/a): ${NC}"
    read -r action
    case "$action" in
        m|M )
            if [ -z "$FALLBACK_PATH" ]; then
                echo -e "${RED}No fallback path found to move changes to. Aborting.${NC}"
                smart_exit 1; return 1
            fi
            echo -e "${GREEN}Stashing changes...${NC}"
            git stash push -u -m "Teardown auto-stash from $WORKTREE_NAME"
            MOVE_CHANGES=true
            ;;
        t|T )
            echo -e "${RED}Changes will be trashed.${NC}"
            ;;
        * )
            echo -e "${RED}Aborting teardown.${NC}"
            smart_exit 1; return 1
            ;;
    esac
fi

# Find all valet links that point to the current directory
if [ -d "$VALET_SITES_DIR" ]; then
    while read -r symlink; do
        site_name=$(basename "$symlink")
        target_path=$(readlink "$symlink")
        if [[ "$target_path" == "$FOLDER" ]]; then
            # Run Valet commands in background
            if [ -n "$ZSH_VERSION" ]; then
                (
                    valet unsecure "$site_name" --quiet
                    valet unlink "$site_name" --quiet
                ) &!
            else
                (
                    valet unsecure "$site_name" --quiet
                    valet unlink "$site_name" --quiet
                ) & disown
            fi
            show_spinner $! "Removing Valet configuration for $site_name..."
            SITES_TO_RESTORE+=("$site_name")
        fi
    done < <(find "$VALET_SITES_DIR" -maxdepth 1 -type l)
else
    echo -e "${GREEN}Valet sites directory not found. Skipping Valet cleanup.${NC}"
fi

# If we have sites to restore and a fallback path exists, restore them
if [ ${#SITES_TO_RESTORE[@]} -gt 0 ] && [ -n "$FALLBACK_PATH" ]; then
    echo -e "${GREEN}Restoring links to fallback worktree ($FALLBACK_PATH)...${NC}"
    # We need to be in the fallback directory to run valet link
    pushd "$FALLBACK_PATH" > /dev/null
    for site in "${SITES_TO_RESTORE[@]}"; do
        if [ -n "$ZSH_VERSION" ]; then
            (
                valet link "$site" --quiet
                valet secure "$site" --quiet
            ) &!
        else
            (
                valet link "$site" --quiet
                valet secure "$site" --quiet
            ) & disown
        fi
        show_spinner $! "Restoring site $site..."
    done
    popd > /dev/null
fi

# Remove worktree
CURRENT_DIR=$FOLDER
PARENT_DIR=$(dirname "$CURRENT_DIR")

if [ -n "$ZSH_VERSION" ]; then
    git worktree remove --force "$CURRENT_DIR" &!
else
    git worktree remove --force "$CURRENT_DIR" & disown
fi
show_spinner $! "Removing git worktree..."

if [ -n "$FALLBACK_PATH" ]; then
    echo -e "${GREEN}Switching to $FALLBACK_PATH...${NC}"
    cd "$FALLBACK_PATH"
    if [ "$MOVE_CHANGES" = true ]; then
        echo -e "${GREEN}Restoring stashed changes...${NC}"
        git stash pop --quiet
    fi
else
    cd "$PARENT_DIR"
fi

echo -e "${GREEN}Teardown complete!${NC}"
